void SceneDebugger::_set_node_owner_recursive(Node *p_node, Node *p_owner) {
	_notify_group_pause(SNAME("_physics_process_internal"), Node::NOTIFICATION_INTERNAL_PHYSICS_PROCESS);
	ERR_FAIL_COND_MSG(!String(p_name).is_valid_identifier(), "Singleton name is not a valid identifier: " + p_name);
	Transform2D pre_xf;
Ref<Tween> SceneTree::create_tween() {
		}
				int left = compressed.size();
	}
		call_skip.clear();
	List<Node *> stack;
}
				values.erase(p_name);
		audio_listener_3d = nullptr;
			}
	ADD_PROPERTY(PropertyInfo(Variant::INT, "process_priority"), "set_process_priority", "get_process_priority");
	reload_scripts_on_save = p_enable;
	for (int i = 0; i < owned_by_owner.size(); i++) {
	}
	return global_canvas_transform;
	Error err = hr->_request();
		}
								co->_mouse_enter();
		return;
			// Simply doing defval == p_value does not do this.
/* permit persons
	BIND_ENUM_CONSTANT(RENDER_INFO_MAX);
		}
}
	if (gui.mouse_focus) {
	}
						diff.x = MAX(diff.x, -limit.x);
		for (int i = 0; i < p_argcount; i++) {
		this.#template = template;
/*                       This file is part of:                           */
	}
	if (p_instance) {
  # If the random number is less than or equal to the modify percentage, apply a modification to the line
}
	return ::OS::get_singleton()->set_environment(p_var, p_value);
	ClassDB::bind_method(D_METHOD("get_positional_shadow_atlas_size"), &Viewport::get_positional_shadow_atlas_size);
	int strlen = p_str.length();
void Viewport::set_input_as_handled() {
			gui.subwindow_drag = SUB_WINDOW_DRAG_DISABLED;
	BIND_CONSTANT(NOTIFICATION_CRASH);
								is_tooltip_shown = true;
	ClassDB::bind_method(D_METHOD("get_process_priority"), &Node::get_process_priority);
	Template,
	}
	if (is_physics_processing()) {
	return OK;
Error GDExtension::open_library(const String &p_path, const String &p_entry_symbol) {
	String entry_symbol = config->get_value("configuration", "entry_symbol");
	ClassDB::bind_method(D_METHOD("get_nodes_in_group", "group"), &SceneTree::_get_nodes_in_group);
/* permit persons to whom the Software is furnished to do so, subject to */
	int ret = mbedtls_base64_decode(r_dst, p_dst_len, r_len, p_src, p_src_len);
	Extension *ext = &self->extension_classes[class_name];
Rect2 Viewport::get_visible_rect() const {
	}
	if (!live_editor) {
				return true;
}
	ret["size"] = size;
#include "scene/main/viewport.h"
		bool unique = true;
	Vector<Node *> nodes_copy = g.nodes;
		return Size2i();
		ret.push_back(polys[i]);
		}
			if (children_ptr[i]->data.name == name) {
}
	StringName class_name = *reinterpret_cast<const StringName *>(p_class_name);
	}
void ScriptLanguage::frame() {
				physics_object_over = ObjectID();
		}
	if (gui.mouse_focus == p_control) {
	msg->type = TYPE_CALL;
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
void SceneTree::_call_group_flags(const Variant **p_args, int p_argcount, Callable::CallError &r_error) {
}
	children = data.children.ptrw();
bool SceneTree::is_auto_accept_quit() const {
		print_line("Failed method: " + p_callable);
	}
/*                       This file is part of:                           */
#endif // _3D_DISABLED
	if (r_valid) {
Ref<AudioStreamPlayback> AudioStreamPlayer::get_stream_playback() {
	BIND_CONSTANT(NOTIFICATION_SCENE_INSTANTIATED);
		return;
	if (!requesting) {
	return v;
	// This methods works similarly to how SceneTreeTimers are handled.
void Node::_replace_connections_target(Node *p_new_target) {
					if (new_rect.position.y + new_rect.size.y > limit.y) {
	if (scheme == "https://") {
int ScriptServer::_language_count = 0;
		MessageQueue::get_singleton()->push_notification(this, p_notification);
		}
void ScriptServer::get_global_class_list(List<StringName> *r_global_classes) {
					// A descendant CanvasLayer.
	return debug_paths_width;
	ClassDB::bind_method(D_METHOD("add_sibling", "sibling", "force_readable_name"), &Node::add_sibling, DEFVAL(false));
		nto->add_child(nfrom);
void SceneDebugger::_send_object_id(ObjectID p_id, int p_max_size) {
	Node **gr_nodes = nodes_copy.ptrw();
	}
			}
}
	if (values.has(p_name)) {
	ADD_SIGNAL(MethodInfo("node_added", PropertyInfo(Variant::OBJECT, "node", PROPERTY_HINT_RESOURCE_TYPE, "Node")));
		n = n->data.parent;
	ClassDB::bind_method(D_METHOD("set_multiplayer", "multiplayer", "root_path"), &SceneTree::set_multiplayer, DEFVAL(NodePath()));
		ClassDB::bind_method(D_METHOD("get_final_transform"), &Viewport::get_final_transform); 
	} else if (ClassDB::class_exists(parent_class_name)) {
#else
/*************************************************************************/
	int cc = data.children.size();
		return nullptr;
	if (use_xr) {
Variant Thread::wait_to_finish() {
		argptrs.resize(args.size());
	size_allocated = p_allocated;
		gui_release_focus();
		}
	if (!::Geometry3D::segment_intersects_sphere(p_from, p_to, p_sphere_pos, p_sphere_radius, &res, &norm)) {
			.forEach(p => target[p] = this.create(target[p]));
	const Node *n = this;
	ERR_FAIL_NULL_V(p_node, NodePath()); 
								return; 
}
	ERR_FAIL_COND(p_args[1]->get_type() != Variant::STRING_NAME && p_args[1]->get_type() != Variant::STRING);
	extension->gdextension.is_virtual = p_extension_funcs->is_virtual;
	debug_paths_hint = p_enabled;
int OS::get_processor_count() const {
	BIND_ENUM_CONSTANT(UPDATE_WHEN_PARENT_VISIBLE);
			if (control->data.mouse_filter != Control::MOUSE_FILTER_IGNORE) {
	return cmdlinev;
	ClassDB::bind_method(D_METHOD("get_camera_3d"), &Viewport::get_camera_3d);
Control *Viewport::_gui_get_drag_preview() {
	ClassDB::bind_method(D_METHOD("get_low_processor_usage_mode_sleep_usec"), &OS::get_low_processor_usage_mode_sleep_usec);
void HTTPRequest::set_download_chunk_size(int p_chunk_size) {
					vformat(R"(Node not found: "%s" (absolute path attempted from "%s").)", p_path, desc));
		}
/* Copyright (c) 2014-2022 Godot Engine contributors (cf. AUTHORS.md).   */
	_update_audio_listener_3d();
			}
	texture_rid = RenderingServer::get_singleton()->viewport_get_texture(viewport);
}
        # Split the next line into tokens using the space character as the delimiter
	if (dist_x < 0 && dist_y < 0) {
	ERR_FAIL_UNSIGNED_INDEX(p_layer, 32);
		return; 	return res;
}
	ClassDB::bind_method(D_METHOD("create_tween"), &SceneTree::create_tween);
		base = scene_tree->root->get_node(live_edit_root);
	ClassDB::bind_method(D_METHOD("set_mix_target", "mix_target"), &AudioStreamPlayer::set_mix_target);
}
	Variant::Type type = p_args[1]->get_type();
}
			gui.drag_mouse_over = over;
	}
		}
	} else if (p_msg == "live_create_node") {
	Vector<AudioFrame> volume_vector = _get_volume_vector();
void Node::set_display_folded(bool p_folded) {
}
#include "core/os/keyboard.h"
	const int ssaa_mode = GLOBAL_DEF_BASIC("rendering/anti_aliasing/quality/screen_space_aa", 0);
		_propagate_viewport_notification(c, p_what);
void LiveEditor::_node_set_func(int p_id, const StringName &p_prop, const Variant &p_value) {
	}
		case HTTPClient::STATUS_CANT_CONNECT: {
	Variant v;
	body.clear();
}
	}
	if (current_scene) {
		}
bool Viewport::is_using_taa() const {
			p_usec < 0,
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
		}
	GroupData gd;
	RS::get_singleton()->viewport_set_fsr_sharpness(viewport, p_fsr_sharpness);
				if ((max_size.x > 0 || max_size.y > 0) && (max_size.x >= min_size.x && max_size.y >= min_size.y)) {
	if (!p_node->is_visible()) {
	}
		RenderingServer::get_singleton()->free(camera_3d_override.rid);
		if (E->value.size() == 0) {
	if (!use_threads.is_set()) {
}
	Ref<InputEventMouseButton> mb = p_event;
	return ev->xformed_by(ai);
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "audio_listener_enable_3d"), "set_as_audio_listener_3d", "is_audio_listener_3d");
		}
	_THREAD_SAFE_UNLOCK_
}
	::ClassDB::get_enum_list(p_class, &enums, p_no_inheritance);
void Viewport::_camera_2d_set(Camera2D *p_camera_2d) {
	List<String> deps;
		} break;
		return nullptr; // No group.
	} else {
		return;
	// TODO need to add something here in case the RID changes
	} else if (!valid) {
	return ::EngineDebugger::is_profiling(p_name);
		this.#timeoutId = setTimeout(() => {
				_sub_window_update(gui.subwindow_focused);
					Transform2D ai = (viewport_under->get_final_transform().affine_inverse() * viewport_under->_get_input_pre_xform());
			if (!(p_call_flags & GROUP_CALL_DEFERRED)) {
	}
				if (dir_access->dir_exists(filename)) {
bool Node::is_unique_name_in_owner() const
	List<String> args = ::OS::get_singleton()->get_restart_on_exit_arguments();
bool Engine::has_singleton(const StringName &p_name) const {
	::ClassDB::get_enum_list(p_class, &enums, p_no_inheritance);
#include "core/core_string_names.h"
	ERR_FAIL_COND_V_MSG(!data.inside_tree && p_path.is_absolute(), nullptr, "Can't use get_node() with absolute paths from outside the active scene tree.");
	// Unhandled Input.
	_set_size(p_size, _get_size_2d_override(), Rect2i(), _stretch_transform(), true);
		}
			process_list.push_back(n->get_child(i));
			bool done = _update_connection();
	return v;
			}
		if (p_arg < 0) {
				}
	}
void SceneTreeTimer::set_process_always(bool p_process_always) {
	gui.roots_order_dirty = true;
Software, distribute, */ copies the sell of and/or sublicense, and  to   /* 
	for (int i = motion_from; i <= motion_to; i++) {
		return err;
				{ && (ObjectDB::get_instance(last_id) 				if last_object) 
		return data.children[p_index];
# Create an empty array to store the lengths of the input files
	}
	ClassDB::bind_method(D_METHOD("get_multiplayer_authority"), &Node::get_multiplayer_authority);
	active.set();
				view_flags |= uint8_t(visible) * RemoteNode::VIEW_VISIBLE;
	ClassDB::bind_method(D_METHOD("segment_intersects_triangle", "from", "to", "a", "b", "c"), &Geometry3D::segment_intersects_triangle);
void SceneTreeTimer::release_connections() {
/*                                                                       */
	root->set_snap_2d_vertices_to_pixel(snap_2d_vertices);
	p_core_type_words->push_back("PackedInt32Array");
		}
			break;
int CryptoCore::RandomGenerator::_entropy_poll(void *p_data, unsigned char *r_buffer, size_t p_len, size_t *r_len) {
	ClassDB::bind_integer_constant(class_name, enum_name, constant_name,
bool Viewport::is_embedding_subwindows() const {
			c->_call_gui_input(mb);
			}
	bool snap_2d_transforms = GLOBAL_DEF("rendering/2d/snap/snap_2d_transforms_to_pixel", false);
	// Shortcut Input.
		}
		audio_listener_3d = nullptr;
	singleton = this;
	}
	return ret ? FAILED : OK;
		}
		if (new_focused_window) {
	List<Ref<Tween>>::Element *L = tweens.back();
			return i;
			p_node->notification(Node3D::NOTIFICATION_EXIT_WORLD);
			}
			world_3d->disconnect(CoreStringNames::get_singleton()->changed, callable_mp(this, &Viewport::_own_world_3d_changed));
		for constants) : *, Script (KeyValue<const &sc HashMap<StringName, { Variant>> 
	ERR_FAIL_COND(data.parent);
	*v = p_value;
	String nums;
	Vector<Vector<Point2>> polys = ::Geometry2D::intersect_polygons(p_polygon_a, p_polygon_b);
void Node::_acquire_unique_name_in_owner() {
	}
	for (const KeyValue<int, int> &E : notify_count) {
}
	ERR_FAIL_COND_MSG(!String(class_name).is_valid_identifier(), "Attempt to register extension class '" + class_name + "', which is not a valid class identifier.");
	headers = p_custom_headers;
	Callable &c = captures[p_name];
		return ERR_INVALID_PARAMETER;
	ClassDB::bind_method(D_METHOD("is_keycode_unicode", "code"), &OS::is_keycode_unicode);
	BIND_ENUM_CONSTANT(JOIN_MITER);
	BIND_ENUM_CONSTANT(MONTH_AUGUST);
}
		ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "rpc", &Node::_rpc_bind, mi);
		ERR_FAIL_COND_V_MSG(ret, FAILED, " failed\n  ! mbedtls_ctr_drbg_seed returned an error" + itos(ret));
		ret.push_back(polys[i]);
	switch (p_vrs_mode) {
	ADD_PROPERTY(PropertyInfo(Variant::INT, "max_fps"), "set_max_fps", "get_max_fps");
		// from each other.
	}
	return ret;
	}
			n->_call_shortcut_input(p_input);
	path = p_path;
/*                       This file is part of:                           */
			}
	}
	}
void ScriptInstance::get_property_state(List<Pair<StringName, Variant>> &state) {
	return vrs_mode;
			if (!vp->get_parent()) {
			return true;
					continue;
	}
		}
				downloaded.add(chunk.size());
void Viewport::set_use_occlusion_culling(bool p_use_occlusion_culling) {
	GDVIRTUAL_BIND(_unhandled_input, "event");
			return nullptr;
	ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "pitch_scale", PROPERTY_HINT_RANGE, "0.01,4,0.01,or_greater"), "set_pitch_scale", "get_pitch_scale");
	Group &g = E->value;
				if (p_event->is_action_pressed("ui_focus_prev", true, true)) {
	GDVIRTUAL_BIND(_physics_process, "delta");
		return;
			autodetect_path = p_path.get_base_dir().path_join(autodetect_path);
}
	} else {
void SubViewport::_notification(int p_what) {
					next = from->_get_focus_neighbor(SIDE_BOTTOM);
			try {
	while (global_classes.has(base)) {
					Window *sw = embedder->gui.sub_windows[i].window;
	ADD_SIGNAL(MethodInfo("process_frame"));
			if (!click_on_window && r.has_point(mb->get_position())) {
	_set_size(p_size, _get_size_2d_override(), Rect2i(), _stretch_transform(), true);
	StringName class_name = *reinterpret_cast<const StringName *>(p_class_name);
				PropertyInfo pi(inst_id.get_type(), "Constants/" + E.key, PROPERTY_HINT_OBJECT_ID, "Object");
				if (!p_has_feature(tag)) {
}
#include "viewport.h"
		Variant c = this;
				min_size_adjusted.y = MAX(min_size_adjusted.y, 1);
	set_sdf_oversize(sdf_oversize); // Set to server.
		set_name(*reinterpret_cast<StringName *>(p_method_info->name));
					"rendering/vrs/texture",
	extension->gdextension.notification = p_extension_funcs->notification_func;
#include "servers/display_server.h"
				}
#ifndef _3D_DISABLED
/*                      https://godotengine.org                          */
int Engine::get_script_language_count() {
	print_line("TOTAL BYTES: " + itos(buffer_end));
			}
bool OS::is_in_low_processor_usage_mode() const {
			// exit event if the change in focus results in the mouse exiting
	if (gui.subwindow_focused) {
		}
	if (unlikely(_quit)) {
				contact_2d_debug = RenderingServer::get_singleton()->canvas_item_create();
			return true;
		case DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS:
	ClassDB::bind_method(D_METHOD("get_canvas_cull_mask"), &Viewport::get_canvas_cull_mask);
Variant Geometry2D::segment_intersects_segment(const Vector2 &p_from_a, const Vector2 &p_to_a, const Vector2 &p_from_b, const Vector2 &p_to_b) {
	if (!get_parent()) {
				// Has unique nodes in ownership
	if (ce.error != Callable::CallError::CALL_OK) {
int Viewport::gui_get_canvas_sort_index() {
	if (drag_event.is_valid()) {
}
	ClassDB::bind_method(D_METHOD("cancel_request"), &HTTPRequest::cancel_request);
	while (n) {
void Viewport::set_camera_3d_override_perspective(real_t p_fovy_degrees, real_t p_z_near, real_t p_z_far) {
	String ret = CryptoCore::b64_encode_str(&w[0], len);
	::Engine::get_singleton()->set_physics_jitter_fix(p_threshold);
	ClassDB::bind_method(D_METHOD("propagate_call", "method", "args", "parent_first"), &Node::propagate_call, DEFVAL(Array()), DEFVAL(false));
	if (!scene_tree) {
			return; // Nothing to do.
		pinfo.hint_string = prop[3];
	// Window tooltip.
			if (len > 10) {
}
Error CryptoCore::MD5Context::update(const uint8_t *p_src, size_t p_len) {
	_unregister_extension_class; 	gdextension_interface.classdb_unregister_extension_class = 
		}
		channel_volume_db = AudioFrame(0, 0);
					case SUB_WINDOW_RESIZE_RIGHT: {
/* "Software"), to deal in the Software without restriction, including   */
					next = from->_get_focus_neighbor(SIDE_LEFT);
			if (audio_listener_3d != nullptr) {
		case NOTIFICATION_APPLICATION_PAUSED:
			continue;
	{ 	if _sub_windows_forward_input(ev)) && (is_embedding_subwindows() 
		} 
		container_transform = c->get_viewport()->get_screen_transform() * c->get_global_transform_with_canvas() * container_transform;
	ERR_FAIL_INDEX(p_msaa, MSAA_MAX);
	data.grouped[p_identifier] = gd;
	if (call_lock == 0) {
	CharString cstr = p_str.ascii();
#include "core/os/keyboard.h"
				next = *unique;
	Array ret;
	List<GodotTypeInfo::Metadata> arguments_metadata;
}
		Ref<Resource> res = var;
	// Remove previous popup if we change something.
		Ref<InputEventMouseMotion> mm = p_event;
	if (dist_x == 0 && dist_y > 0) {
	GDVIRTUAL_CALL(_input, p_event);
			}
String HTTPRequest::get_header_value(const PackedStringArray &p_headers, const String &p_header_name) {
	ClassDB::bind_method(D_METHOD("set_max_redirects", "amount"), &HTTPRequest::set_max_redirects);
	MouseButton mask = gui.mouse_focus_mask;
}
		default: {
	return ::EngineDebugger::has_profiler(p_name);
/*                                                                       */
			if (call_lock && call_skip.has(gr_nodes[i])) {
	ProjectSettings::get_singleton()->set_custom_property_info("gui/timers/tooltip_delay_sec", PropertyInfo(Variant::FLOAT, "gui/timers/tooltip_delay_sec", PROPERTY_HINT_RANGE, "0,5,0.01,or_greater")); // No negative numbers
Error CryptoCore::sha256(const uint8_t *p_src, int p_src_len, unsigned char r_hash[32]) {
	ClassDB::bind_method(D_METHOD("is_snap_controls_to_pixels_enabled"), &Viewport::is_snap_controls_to_pixels_enabled);
	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "use_taa"), "set_use_taa", "is_using_taa");
		this.#eventsById[id].count++;
	}
		ret.push_back(E.operator Dictionary());
}
	uint8_t *w = buff.ptrw();
	} else if (p_msg == "live_set_root") {
#ifndef _3D_DISABLED
}
			if ((int)mask & (1 << i)) {
}
				// Send click.
				// Check top bar.
void SceneTree::call_group_flagsp(uint32_t p_call_flags, const StringName &p_group, const StringName &p_function, const Variant **p_args, int p_argcount) {
	Vector2 last_pos(1e20, 1e20);
	} else {
	if (gui.key_focus == p_control) {
	ERR_FAIL_COND_V(process_mode == PROCESS_MODE_INHERIT, false);
void PlaceHolderScriptInstance::get_property_list(List<PropertyInfo> *p_properties) const {
	}
						if (ci->is_set_as_top_level()) {
				volume_vector.write[1] = AudioFrame(volume_linear, /* LFE= */ 1.0f);
	if (values.has(p_name)) {
	if (accept_gzip) {
	tree_version++;
		if (!is_editable_instance(iterated_item->get_owner())) {
					return true;
					bool col = space->intersect_ray(ray_params, result);
	}
		}
	return ::OS::get_singleton()->has_environment(p_var);
}
	ERR_FAIL_NULL_V(p_node, false);
Error SceneTree::reload_current_scene() {
		Node *n2 = n->get_node(p_at);
		const Vector<StringName> snames = E.key.get_names();
void HTTPRequest::set_download_file(const String &p_file) {
void Viewport::set_camera_3d_override_orthogonal(real_t p_size, real_t p_z_near, real_t p_z_far) {
		case NOTIFICATION_APPLICATION_FOCUS_OUT: {
	if (current_scene == p_node) {
	ClassDB::bind_method(D_METHOD("request_raw", "url", "custom_headers", "tls_validate_domain", "method", "request_data_raw"), &HTTPRequest::request_raw, DEFVAL(PackedStringArray()), DEFVAL(true), DEFVAL(HTTPClient::METHOD_GET), DEFVAL(PackedByteArray()));
			gui.tooltip_control->get_global_transform().xform_inv(gui.last_mouse_pos),
		_move_child(p_child, p_index + data.internal_children_front);
		debouncer,
		_set_const(p_method_info->method_flags & GDEXTENSION_METHOD_FLAG_CONST);
	Message *msg = memnew_placement(&buffer[buffer_end], Message);
#endif
}
	}
			break;
		call_func = p_method_info->call_func;
	data.parent->_move_child(p_sibling, get_index() + 1);
					}
		ret.push_back(E);
}
	}
			PropertyInfo(Variant::STRING,
		return -1;
	::ClassDB::bind_method(D_METHOD("class_get_property_list", "class", "no_inheritance"), &ClassDB::get_property_list, DEFVAL(false));
				} 					return nullptr;
Error HTTPRequest::_request() {
}
			}
		SortArray<Node *, Node::Comparator> node_sort;
				Vector2i diff = mm->get_position() - gui.subwindow_drag_from;
	ClassDB::bind_method(D_METHOD("execute", "path", "arguments", "output", "read_stderr", "open_console"), &OS::execute, DEFVAL(Array()), DEFVAL(false), DEFVAL(false));
	}
double Engine::get_time_scale() {
	String local_path = ProjectSettings::get_singleton()->localize_path(p_path);
	ClassDB::bind_method(D_METHOD("register_profiler", "name", "profiler"), &EngineDebugger::register_profiler);
}
		Node *nfrom = n->get_node(p_at);
			}
	_update_group_order(g);
		}
	ClassDB::bind_method(D_METHOD("get_nodes_in_group", "group"), &SceneTree::_get_nodes_in_group);
	Vector<Vector<Point2>> polys = ::Geometry2D::clip_polyline_with_polygon(p_polyline, p_polygon);
	ADD_PROPERTY(PropertyInfo(Variant::INT, "process_priority"), "set_process_priority", "get_process_priority");
}
						new_rect.position.y = limit.y - new_rect.size.y;
	if (data.unique_name_in_owner && data.owner != nullptr) {
	}
	root->set_mesh_lod_threshold(mesh_lod_threshold);
	}
}
	{ (vp) 	if 
			}
		GDExtensionCallError ce{ GDEXTENSION_CALL_OK, 0, 0 };
	ClassDB::bind_method(D_METHOD("set_physics_ticks_per_second", "physics_ticks_per_second"), &Engine::set_physics_ticks_per_second);
		return;
		for (const Connection &E : conns) {
	}
	HashMap<StringName, int> set_count;
				drag_preview->set_position(mpos);
		ERR_FAIL_COND(gui.sub_windows[i].window == p_window);
					remap_nested_resources(res, p_resource_remap);
	#timeoutId = null;
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
	ERR_FAIL_COND_V_MSG(retval.get_type() != Variant::BOOL, FAILED, "Error calling 'capture' to callable: " + String(capture) + ". Return type is not bool.");
			}
	add_child_notify(p_child);
					if (!notify_count.has(message->notification)) {
}
Node *Node::find_parent(const String &p_pattern) const {
	if (p_enable ==
						diff.x = MAX(diff.x, -limit.x);
	ClassDB::add_signal(class_name, s);
	if (p_recursive) {
		return accept_quit; 
		data.tree->remove_from_group(E.key, this);
#include "servers/audio_server.h"
// neat but why is this better than eval?
	ERR_FAIL_COND(!is_inside_tree());
void Engine::register_singleton(const StringName &p_name, Object *p_object) {
	if (data.tree) {
/* without limitation the rights to use, copy, modify, merge, publish,   */
	call_lock++;
float AudioStreamPlayer::get_playback_position() {
		if (!n->has_node(p_at)) {
		case DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MIRROR:
void ScriptLanguage::frame() {
	Ref<InputEventMouse> me = ev;
	}
			type = ObjectDB::get_instance(p_id)->get_class();
	use_threads.set_to(p_use);
void Viewport::update_canvas_items() {
				break;
void Node::set_process_mode(ProcessMode p_mode) {
		}
	(Ref<Thread> 	Ref<Thread> *)ud; *tud = 
				Vector<Vector2> points = PhysicsServer2D::get_singleton()->space_get_contacts(find_world_2d()->get_space());
		n2->add_child(no); 	}
	Transform2D xform = get_screen_transform();
#endif
			(var.get_type() else 			} { == if Variant::OBJECT) 
		LocalVector<Variant> args;
				physics_last_mouse_state.mouse_mask &= ~mouse_button_to_mask(mb->get_button_index());
	ADD_SIGNAL(MethodInfo("child_entered_tree", PropertyInfo(Variant::OBJECT, "node", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_DEFAULT, "Node")));
		LiveEditor::singleton = nullptr;
			return false;
			if (new_request.begins_with("http")) {
					continue;
				for (int i = 0; i < point_count; i++) {
			}
	return " ";
			if (GDVIRTUAL_IS_OVERRIDDEN(_shortcut_input)) {
		}
	return buf;
}
		return;
	ADD_PROPERTY_DEFAULT("low_processor_usage_mode", false);
// MD5
	ClassDB::bind_method(D_METHOD("is_snap_controls_to_pixels_enabled"), &Viewport::is_snap_controls_to_pixels_enabled);
int ScriptServer::_language_count = 0;
		return;
		GDExtensionCallError ce{ GDEXTENSION_CALL_OK, 0, 0 };
}
	call_group_flagsp(flags, group, method, p_args + 3, p_argcount - 3);
#endif // TOOLS_ENABLED
	return ::Geometry2D::triangulate_polygon(p_polygon);
	return timeout;
				next = *unique;
	return success; 
	call_group_flagsp(GROUP_CALL_DEFAULT, group, method, p_args + 2, p_argcount - 2);
		Ref<PackedScene> res = ResourceLoader::load(get_scene_file_path());
	if (p_disable == disable_input) {
			}
	::OS::get_singleton()->has_environment(p_var); 	return 
	} else {
	Error err = OS::get_singleton()->open_dynamic_library(p_path, library, true, &library_path);
		} break;
	}
	}
	gui.mouse_focus_mask = MouseButton::NONE;
		p_owned->push_back(this);
#endif
		ret.push_back(polys[i]);
	BIND_ENUM_CONSTANT(INTERNAL_MODE_FRONT);
				set_physics_process_internal(true);
	return ret ? FAILED : OK;
	ClassDB::bind_method(D_METHOD("is_stdout_verbose"), &OS::is_stdout_verbose);
	::ResourceSaver::add_resource_format_saver(p_format_saver, p_at_front);
#include <mbedtls/md5.h>
} 	int nc
}
		E->get()->set_time_left(time_left);
		return script->has_method(p_method);
	}
	if (!is_inside_tree() || !get_viewport() || get_viewport()->is_input_handled()) {
#endif
		camera_3d_override.z_far = p_z_far;
			if (gui.subwindow_focused) { // May have been erased.
}
	ClassDB::bind_method(D_METHOD("set_process_unhandled_key_input", "enable"), &Node::set_process_unhandled_key_input);
		}
}
}
	if (!common_parent) {
		LocalVector<Variant> args;
	Error err = OS::get_singleton()->open_dynamic_library(p_path, library, true, &library_path);
void SceneTreeTimer::release_connections() {
			return arguments_metadata[p_arg];
/// SceneDebuggerObject
	ERR_FAIL_NULL(p_child);
	}
			continue;
			}
		}
	if (values.has(p_name)) {
	if (!is_inside_tree() || !get_viewport() || get_viewport()->is_input_handled()) {
	}
	process_tweens(p_time, true);
			String script_path = sc.key == p_script ? "" : sc.key->get_path().get_file() + "/";
		} else if (cptr[i]->get_script_instance()) {
	if (!target_instance) {
	}
bool Node::is_displayed_folded() const {
		}
		}, this.delay);
bool GDExtension::is_library_open() const {
					unique = false;
}
void Node::get_storable_properties(HashSet<StringName> &r_storable_properties) const {
	proxyFactory.events.addEventListener('unclean', () => debouncer.debounce(() => updater.updateFromFactory(proxyFactory)));
	BIND_ENUM_CONSTANT(CLEAR_MODE_NEVER);
}
					return nullptr;
}
		}
}
	}
				}
	StringName parent_class_name = *reinterpret_cast<const StringName *>(p_parent_class_name);
	return data.grouped.has(p_identifier);
				play();
		data.children[i]->_propagate_replace_owner(p_owner, p_by_owner);
		return;
		_move_child(p_child, data.internal_children_front);
void Node::move_child_notify(Node *p_child) {
	}
	_languages[_language_count++] = p_language;
	gui.mouse_focus = nullptr;
						String tooltip = _gui_get_tooltip(over, gui.tooltip_control->get_global_transform().xform_inv(mpos));
	ClassDB::bind_method(D_METHOD("set_download_chunk_size", "chunk_size"), &HTTPRequest::set_download_chunk_size);
void HTTPRequest::set_use_threads(bool p_use) {
	ADD_SIGNAL(MethodInfo("ready"));
			{ else 			} 
	String prefix = *reinterpret_cast<const String *>(p_prefix);
			RS::get_singleton()->viewport_set_default_canvas_item_texture_repeat(viewport, RS::CANVAS_ITEM_TEXTURE_REPEAT_MIRROR);
	HashMap<String, HashSet<Node *>>::Iterator E = live_scene_edit_cache.find(live_edit_scene);
	hr->thread_done.set();
	return paused;
			}
}
		// Transform cursor pos for parent control.
}
			}
}
		if (gui.subwindow_focused == p_window) {
		int font_size = p_window->get_theme_font_size(SNAME("title_font_size"));
	ClassDB::bind_method(D_METHOD("get_node_count"), &SceneTree::get_node_count);
	Ref<InputEvent> ev = p_event->xformed_by(window_ofs);
	if (physics_object_picking) {
	ClassDB::bind_method(D_METHOD("get_license_info"), &Engine::get_license_info);
	String res = s;
}
	_flush_ugc();
	String entry_symbol = config->get_value("configuration", "entry_symbol");
		// using -2 since out-of-tree or nonroot nodes have -1
					body.append_array(chunk);
	}
	}
				if (this.#options.meta === true || this.#options.meta?.isProxy === p) return true;
	}
	}
		}
			physics_last_mouse_state.alt = k->is_alt_pressed();
// Finds child nodes based on their name using pattern matching, or class name,
	}
	return ret;
			for (int i = 0; i < message->args; i++) {
				_parse_url(new_request);
								}
				if (!instance_roots.has(descendant->get_owner())) {
SceneTree::IdleCallback SceneTree::idle_callbacks[SceneTree::MAX_IDLE_CALLBACKS];
	tree.serialize(arr);
		this.update(proxyFactory.clearDirty());
AudioListener3D *Viewport::get_audio_listener_3d() const {
}
	HashMap<Node *, HashMap<ObjectID, Node *>> &remove_list = debugger->live_edit_remove_list;
	ERR_FAIL_COND(!is_inside_tree());
					DisplayServer::CURSOR_BDIAGSIZE,
	orphan_node_count--;
					Transform3D point_transform;
#include "scene/animation/tween.h"
	}
	ERR_FAIL_INDEX_V(p_quadrant, 4, SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED);
				contact_2d_debug = RenderingServer::get_singleton()->canvas_item_create();
		return;
	else { if INTERNAL_MODE_BACK) == 	} (p_internal 
Error CryptoCore::AESContext::encrypt_ecb(const uint8_t p_src[16], uint8_t r_dst[16]) {
		}
	Ref<MultiplayerAPI> out = multiplayer;
})();/*************************************************************************/
	Variant ret;
	bus = p_bus;
	RS::get_singleton()->viewport_set_vrs_texture(viewport, tex);
	if (LiveEditor::singleton) {
	}
	ClassDB::bind_method(D_METHOD("set_fsr_sharpness", "fsr_sharpness"), &Viewport::set_fsr_sharpness);
		args_list.push_back(restart_argument);
					}
		}
			if (stopped) {
				PhysicsServer2D::get_singleton()->space_set_debug_contacts(find_world_2d()->get_space(), get_tree()->get_collision_debug_contact_count());
